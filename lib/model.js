// Generated by CoffeeScript 1.6.3
(function() {
  var Backbone, Decoratable, Model, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Backbone = require('backbone');

  _ = require('underscore');

  Decoratable = require('./decoratable.js');

  Model = (function(_super) {
    __extends(Model, _super);

    function Model() {
      _ref = Model.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    Inline functionality to mixin classes
    
    `@::mixin(ClassName)` is how you do it.
    */


    Model.prototype.mixin = function(Class) {
      var key, value, _ref1, _results;
      _ref1 = Class.prototype;
      _results = [];
      for (key in _ref1) {
        value = _ref1[key];
        _results.push(this[key] = value);
      }
      return _results;
    };

    Model.prototype.mixin(Decoratable);

    /*
    Returns the model after this model in its collection. If it's not in a
    collection this will return null.
    */


    Model.prototype.next = function() {
      var _ref1;
      return (_ref1 = this.collection) != null ? _ref1.after(this) : void 0;
    };

    /*
    Returns the model before this model in its collection. If it's not in a
    collection this will return null.
    */


    Model.prototype.prev = function() {
      var _ref1;
      return (_ref1 = this.collection) != null ? _ref1.before(this) : void 0;
    };

    /*
    Override the set method to allow for casting as data comes in.
    */


    Model.prototype.set = function(key, val, options) {
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        attrs = {};
        attrs[key] = val;
      }
      if (this.types) {
        for (key in attrs) {
          val = attrs[key];
          if (!_.isUndefined(this.types[key])) {
            attrs[key] = this.cast(val, this.types[key]);
          }
        }
      }
      return Model.__super__.set.call(this, attrs, options);
    };

    /*
    Take a value, and a casting definition and perform the cast
    */


    Model.prototype.cast = function(value, cast) {
      var error;
      try {
        return value = this.getCastFunc(cast)(value);
      } catch (_error) {
        error = _error;
        return value = null;
      } finally {
        return value;
      }
    };

    /*
    Given a casting definition, return a function that should perform the cast
    */


    Model.prototype.getCastFunc = function(cast) {
      if (_.isFunction(cast)) {
        return cast;
      }
      switch (cast) {
        case 'string':
          return function(v) {
            if (v === null) {
              return null;
            } else {
              return v + '';
            }
          };
        case 'int':
          return function(v) {
            if (v === null) {
              return null;
            } else {
              return Math.floor(+v);
            }
          };
        case 'float':
          return function(v) {
            if (v === null) {
              return null;
            } else {
              return +v;
            }
          };
        case 'boolean':
          return function(v) {
            if (v === null) {
              return null;
            } else {
              return !!v;
            }
          };
        default:
          return function(v) {
            return v;
          };
      }
    };

    return Model;

  })(Backbone.Model);

  module.exports = Model;

}).call(this);
