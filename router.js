// Generated by CoffeeScript 1.8.0
(function() {
  var Backbone, Router, difference, extend, getIndexes, getNames, isFunction, isRegExp, keys, object, pluck, process, querystring, sortBy, splice, zip, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Backbone = require('backbone');

  querystring = require('querystring');

  _ = require('underscore');

  extend = _.extend, object = _.object, isRegExp = _.isRegExp, isFunction = _.isFunction, zip = _.zip, pluck = _.pluck, sortBy = _.sortBy, keys = _.keys;

  difference = _.difference;

  getNames = function(string) {
    var ret;
    ret = [];
    ret.push.apply(ret, process(string, /(\(\?)?:\w+/g));
    ret.push.apply(ret, process(string, /\*\w+/g));
    return ret;
  };

  process = function(string, regex) {
    var indexes, matches, _ref;
    matches = (_ref = string.match(regex)) != null ? _ref : [];
    indexes = getIndexes(string, regex);
    return zip(matches, indexes);
  };

  getIndexes = function(string, regex) {
    var ret;
    ret = [];
    while (regex.test(string)) {
      ret.push(regex.lastIndex);
    }
    return ret;
  };

  splice = function(source, from, to, replacement) {
    if (replacement == null) {
      replacement = '';
    }
    return source.slice(0, from) + replacement + source.slice(to);
  };

  Router = (function(_super) {
    __extends(Router, _super);


    /*
    Override so our _routes object is unique to each router. I hate this side of
    js.
     */

    function Router() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._routes = {};
      Router.__super__.constructor.apply(this, args);
    }


    /*
    Override route to perform some subtle tweaks! Namely, storing raw string
    routes for reverse routing and passing the name to the buildRequest function
     */

    Router.prototype.route = function(route, name, callback) {
      if (!isRegExp(route)) {
        this._routes[name] = route;
        route = this._routeToRegExp(route);
      }
      if (isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) {
        callback = this[name];
      }
      return Backbone.history.route(route, (function(_this) {
        return function(fragment) {
          var req;
          req = _this._buildRequest(route, fragment, name);
          _this.execute(callback, req);
          _this.trigger.apply(_this, ['route:' + name, req]);
          _this.trigger('route', name, req);
          return Backbone.history.trigger('route', _this, name, req);
        };
      })(this));
    };


    /*
    Store names of parameters in a propery of route
     */

    Router.prototype._routeToRegExp = function(route) {
      var names, ret;
      ret = Router.__super__._routeToRegExp.call(this, route);
      names = getNames(route);
      ret.names = pluck(sortBy(names, '1'), '0').map(function(s) {
        return s.slice(1);
      });
      return ret;
    };


    /*
    Create a request object. It should have the route name, named segments as
    keys with their values and a query object which is the query params, an
    empty object if no query params available.
     */

    Router.prototype._buildRequest = function(route, fragment, name) {
      var names, query, req, values, _ref;
      values = this._extractParameters(route, fragment);
      query = fragment.split('?').slice(1).join('?');
      if (values[values.length - 1] === query) {
        values = values.slice(0, -1);
      }
      names = (_ref = route.names) != null ? _ref : values.map(function(v, i) {
        return i;
      });
      req = {
        route: route,
        fragment: fragment,
        name: name,
        values: values,
        params: object(names, values),
        query: querystring.parse(query)
      };
      return req;
    };


    /*
    Rather than the default backbone behaviour of applying the args to the
    callback, call the callback with the request object.
     */

    Router.prototype.execute = function(callback, req) {
      if (callback) {
        return callback.call(this, req);
      }
    };


    /*
    Reverse a named route with a barebones request object.
     */

    Router.prototype.reverse = function(name, req) {
      var diff, lastIndex, nameds, names, optional, optionals, params, query, ret, route, segment, value, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
      route = this._routes[name];
      if (!route) {
        return null;
      }
      ret = route;
      params = (_ref = req.params) != null ? _ref : {};
      query = (_ref1 = req.query) != null ? _ref1 : {};
      names = keys(params);
      optionals = process(route, /\((.*?)\)/g).reverse();
      for (_i = 0, _len = optionals.length; _i < _len; _i++) {
        _ref2 = optionals[_i], optional = _ref2[0], lastIndex = _ref2[1];
        nameds = pluck(getNames(optional), '0').map(function(s) {
          return s.slice(1);
        });
        diff = difference(nameds, names).length;
        if (nameds.length === 0 || diff !== 0) {
          route = splice(route, lastIndex - optional.length, lastIndex);
        } else {
          route = splice(route, lastIndex - optional.length, lastIndex, optional.slice(1, -1));
        }
      }
      nameds = getNames(route).reverse();
      for (_j = 0, _len1 = nameds.length; _j < _len1; _j++) {
        _ref3 = nameds[_j], segment = _ref3[0], lastIndex = _ref3[1];
        value = (_ref4 = params[segment.slice(1)]) != null ? _ref4 : null;
        if (value !== null) {
          route = splice(route, lastIndex - segment.length, lastIndex, params[segment.slice(1)]);
        }
      }
      query = querystring.stringify(query);
      if (query) {
        route += '?' + query;
      }
      return route;
    };

    return Router;

  })(Backbone.Router);

  module.exports = Router;

}).call(this);
